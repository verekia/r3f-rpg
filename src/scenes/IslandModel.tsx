/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.0 island.glb -t -T 
Files: island.glb [76.88KB] > /Users/verekia/Local/Code/r3f-rpg/public/models/island/island-transformed.glb [6.53KB] (92%)
*/

import { useEffect } from 'react'

import { useGLTF } from '@react-three/drei'
import { BufferAttribute, BufferGeometry, Mesh, MeshBasicMaterial, Vector3 } from 'three'
import { GLTF } from 'three-stdlib'

import useStore from '#/core/store'

type GLTFResult = GLTF & {
  nodes: {
    Island: THREE.Mesh
  }
  materials: {
    PaletteMaterial001: THREE.MeshStandardMaterial
  }
}

export function Model(props: JSX.IntrinsicElements['group']) {
  const { nodes, materials } = useGLTF('/models/island/island-transformed.glb') as GLTFResult

  const navmesh = useStore(s => s.navmesh)
  const setNavmesh = useStore(s => s.setNavmesh)

  useEffect(() => {
    const geometry = nodes.Island.geometry

    // if (!geometry.hasAttribute('normal')) {
    //   geometry.computeVertexNormals()
    // }

    const positionAttribute = geometry.getAttribute('position')
    // const normalAttribute = geometry.getAttribute('normal
    const indexAttribute = geometry.getIndex()

    const navmeshIndices = []
    const upVector = new Vector3(0, 1, 0)

    const steepnessThreshold = Math.PI / 4

    for (let i = 0; i < indexAttribute.count; i += 3) {
      const idxA = indexAttribute.getX(i)
      const idxB = indexAttribute.getX(i + 1)
      const idxC = indexAttribute.getX(i + 2)

      // Should be optimized for less GC
      const vA = new Vector3().fromBufferAttribute(positionAttribute, idxA)
      const vB = new Vector3().fromBufferAttribute(positionAttribute, idxB)
      const vC = new Vector3().fromBufferAttribute(positionAttribute, idxC)

      const edge1 = new Vector3().subVectors(vB, vA)
      const edge2 = new Vector3().subVectors(vC, vA)
      const normal = new Vector3().crossVectors(edge1, edge2).normalize()

      // Note: It seems like normals are not calculated correctly. When they are, use a code like this instead:
      // https://github.com/verekia/r3f-rpg/commit/61408d448e36bdb552982a79410504786e073047

      // const normal = new Vector3(
      //   normalAttribute.getX(i),
      //   normalAttribute.getY(i),
      //   normalAttribute.getZ(i),
      // )

      if (normal.dot(upVector) < steepnessThreshold) continue

      navmeshIndices.push([idxA, idxB, idxC])
    }

    const navmeshGeometry = new BufferGeometry()
    const flatNavmeshIndices = navmeshIndices.flat()
    const navmeshIndexAttribute = new BufferAttribute(new Uint32Array(flatNavmeshIndices), 1)

    navmeshGeometry.setAttribute('position', positionAttribute)
    navmeshGeometry.setIndex(navmeshIndexAttribute)

    const navmeshMaterial = new MeshBasicMaterial({ color: 0xff0000, wireframe: true })
    const newNavmesh = new Mesh(navmeshGeometry, navmeshMaterial)

    navmeshGeometry.computeBoundingBox()
    navmeshGeometry.computeBoundingSphere()

    setNavmesh(newNavmesh)
  }, [nodes.Island.geometry, setNavmesh])

  return (
    <group {...props} dispose={null}>
      <mesh geometry={nodes.Island.geometry}>
        <meshLambertMaterial map={materials.PaletteMaterial001.map} />
      </mesh>
      {navmesh && <primitive object={navmesh} />}
    </group>
  )
}

useGLTF.preload('/models/island/island-transformed.glb')
